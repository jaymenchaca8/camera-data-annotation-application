<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{margin-left:72pt;padding-top:14pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{margin-left:72pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c20{padding-top:0pt;padding-bottom:16pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c16{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c12{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:italic}.c5{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c2{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c22{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c6{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c15{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c19{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c21{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:right}.c11{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c8{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c13{color:inherit;text-decoration:inherit}.c14{font-size:22pt}.c18{font-style:italic}.c7{margin-left:36pt}.c4{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c8"><div><p class="c4 c21"><span class="c3"></span></p></div><p class="c22 title" id="h.p4zv0a2xfu0y"><span>Camera Data Annotation Interface: </span><span class="c14">Documentation</span></p><hr><p class="c19 c4"><span class="c3"></span></p><p class="c4 c19"><span class="c3"></span></p><p class="c20 subtitle" id="h.rb5qwfpo6bb8"><span class="c16">Table of Contents</span></p><h3 class="c2 c7" id="h.oax29jj9939v"><span class="c6">Views</span></h3><h4 class="c1" id="h.64ivxnj1akea"><span class="c11"><a class="c13" href="#h.anxwwqnhbclg">Main Window</a></span></h4><h4 class="c1" id="h.gxfncniy8w"><span class="c11"><a class="c13" href="#h.jt5b0efum4tm">Timeline View</a></span></h4><h3 class="c2 c7" id="h.1sqi2lfei6ll"><span class="c6">Annotating &amp; Labeling</span></h3><h4 class="c1" id="h.xgi00juh5ojp"><span class="c11"><a class="c13" href="#h.492hjknjun6f">Annotations</a></span></h4><h4 class="c1" id="h.g0rw73q10q6y"><span class="c11"><a class="c13" href="#h.rldhwtg7u9ow">Clickable Label</a></span></h4><h4 class="c1" id="h.2a6m9qhyr9up"><span class="c11"><a class="c13" href="#h.ccp809xxhcur">Label Area</a></span></h4><h3 class="c2 c7" id="h.ld7dqxjp57kx"><span class="c6">Dialog Boxes</span></h3><h4 class="c1" id="h.7ahmwzk4ydv7"><span class="c11"><a class="c13" href="#h.a2lg6z8uwj0g">Import Dialog Box</a></span></h4><h4 class="c1" id="h.iwhwazpf6dgg"><span class="c11"><a class="c13" href="#h.xd74jk9v3c8">Export Dialog Box</a></span></h4><h4 class="c1" id="h.ry1vbgquo0ff"><span class="c11"><a class="c13" href="#h.5ssm0cqdh0f4">Settings Dialog Box</a></span></h4><h3 class="c2 c7" id="h.yemvd989pw8l"><span class="c6">Resizing</span></h3><h4 class="c1" id="h.rvicrqegb5t5"><span class="c11"><a class="c13" href="#h.wf5m75t3brjd">Resizable Rectangle Item</a></span></h4><h4 class="c1" id="h.9fkdtx8tf68t"><span class="c11"><a class="c13" href="#h.d2p2m99yh3x5">Resizable Rectangle Item Settings</a></span></h4><h4 class="c1" id="h.ub0yf4n4yl8l"><span class="c11"><a class="c13" href="#h.ccfbmu8ifrub">Resize Directions</a></span><hr style="page-break-before:always;display:none;"></h4><h2 class="c15" id="h.492hjknjun6f"><span class="c9">annotation.h/annotation.cpp</span></h2><h3 class="c2 c7" id="h.9btpfo8snl8u"><span class="c6">void setClassName(QString _class_name);</span></h3><p class="c0"><span class="c3">Changes name of annotation labels</span></p><h3 class="c2 c7" id="h.mmve1ul6xzjv"><span class="c6">QString getClassName();</span></h3><p class="c0"><span class="c3">Returns label name</span></p><h3 class="c2 c7" id="h.y3yvjdx5ej1p"><span class="c6">void setColor(QColor _color);</span></h3><p class="c0"><span class="c3">Changes color of annotation boxes</span></p><h3 class="c2 c7" id="h.xmawb2kx6gv9"><span class="c6">QColor getColor();</span></h3><p class="c0"><span class="c3">Returns color</span></p><h3 class="c2 c7" id="h.nmc9wpgo7oyy"><span>void printList(); </span><span class="c12">Not used</span></h3><p class="c0"><span class="c3">Prints to the console the addresses of the stored QGraphicItems under this specific annotation class </span></p><h3 class="c2 c7" id="h.26koqiku9yfi"><span class="c6">void addBand(QGraphicsItem* box);</span></h3><p class="c0"><span>Appends </span><span class="c18">box</span><span class="c3">&nbsp;to the stored QGraphicsItem list</span></p><h3 class="c2 c7" id="h.290h2mdzqxl6"><span class="c6">void removeBand(QGraphicsItem* box);</span></h3><p class="c0"><span>Removes </span><span class="c18">box </span><span class="c3">from the stored QGraphicsItem list</span></p><h3 class="c2 c7" id="h.ow0nc0308omh"><span class="c6">QGraphicsItem* removeBandAt(int i);</span></h3><p class="c0"><span>Removes QGraphicsItem</span><span class="c18">&nbsp;</span><span>from the stored list at index </span><span class="c18">i</span></p><h3 class="c2 c7" id="h.i6p74ofywyer"><span class="c6">QGraphicsItem* getBandAt(int i);</span></h3><p class="c0"><span>Returns QGraphicsItem</span><span class="c18">&nbsp;</span><span>from the stored list at index </span><span class="c18">i</span></p><h3 class="c2 c7" id="h.vjcn46hjfvm2"><span class="c6">QList&lt;QGraphicsItem*&gt; getList();</span></h3><p class="c0"><span class="c3">Returns the QGraphicsItem list</span></p><h3 class="c2 c7" id="h.skreevtfeux0"><span class="c6">QString whoAmI(QGraphicsItem* box);</span></h3><p class="c0"><span>Checks and returns the class_name if </span><span class="c18">box </span><span>is found within the QGraphicsItem list. Returns an empty QString if it is not found</span></p><h2 class="c15" id="h.rldhwtg7u9ow"><span class="c9">clickablelabel.h/clickablelabel.cpp</span></h2><h3 class="c2 c7" id="h.16picqk2l6bj"><span class="c6">void setFrameNum(int _frame_num);</span></h3><p class="c0"><span class="c3">Changes frame number</span></p><h3 class="c2 c7" id="h.6og40fufw93q"><span class="c6">int getFrameNum();</span></h3><p class="c0"><span class="c3">Returns frame number</span></p><h3 class="c2 c7" id="h.c2w3ffj05ht6"><span class="c6">void setImagePath(QString _image_path);</span></h3><p class="c0"><span class="c3">Changes system path to image</span></p><h3 class="c2 c7" id="h.wkxu4yeiw7s7"><span class="c6">QString getImagePath();</span></h3><p class="c0"><span class="c3">Returns system path to image</span></p><h3 class="c2 c7" id="h.tb8vxyme72ya"><span class="c6">void clicked();</span></h3><p class="c0"><span class="c3">clicked() signal</span></p><h3 class="c2 c7" id="h.tbw7vtaygzmf"><span class="c6">void mousePressEvent(QMouseEvent* event);</span></h3><p class="c0"><span class="c3">Emits clicked() signal on mouse press</span></p><h2 class="c15" id="h.xd74jk9v3c8"><span class="c9">exportdialog.h/exportdialog.cpp</span></h2><h3 class="c2 c7" id="h.t7rhnjgmfoyj"><span class="c6">QString get_path();</span></h3><p class="c10 c7"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns path to user selected directory</span></p><h3 class="c2 c7" id="h.qanmm8x1otz"><span class="c6">void on_pushButton_clicked();</span></h3><p class="c0"><span class="c3">When pushButton is clicked a QFileDialog will pop up allowing the user to browse their system&rsquo;s file system and select a directory to export to. Selected directory will be set to path. </span></p><h2 class="c15" id="h.a2lg6z8uwj0g"><span class="c9">importdialog.h/importdialog.cpp</span></h2><h3 class="c2 c7" id="h.17u224shj6py"><span class="c6">QString get_path();</span></h3><p class="c0"><span class="c3">Returns system path to user selected ros bag file</span></p><h3 class="c2 c7" id="h.hs6yzm5feu48"><span class="c6">QString get_topic();</span></h3><p class="c0"><span class="c3">Returns the currently selected topic from the ui&rsquo;s comboBox</span></p><h3 class="c2 c7" id="h.1zx7binouxi1"><span class="c6">void on_pushButton_clicked();</span></h3><p class="c0"><span class="c3">When pushButton is clicked a QFileDialog will pop up allowing the user to browse their system&rsquo;s file system and select a file to import from. The file name will then be displayed to the ui and the system path stored to path. A QProcess then runs on the script &ldquo;topic_extraction.py&rdquo; using parameters path to extract the topic parameters to a file.This file is then read and the topics are added to the ui&rsquo;s comboBox. </span></p><h3 class="c2 c7" id="h.3qfvixjfc61z"><span class="c6">void on_buttonBox_accepted();</span></h3><p class="c0"><span class="c3">Closes the import ui</span></p><h3 class="c2 c7" id="h.sd95fhnzrcl2"><span class="c6">void on_buttonBox_rejected();</span></h3><p class="c0"><span class="c3">Closes the import ui</span></p><h3 class="c2" id="h.fhwyt8dl5srm"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QString get_box_path();</span></h3><p class="c10"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns system path to user selected file containing bounding box data</span></p><h3 class="c2" id="h.l2ju5qb0f304"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void on_pushButton_2_clicked();</span></h3><p class="c0"><span class="c3">When pushButton is clicked a QFileDialog will pop up allowing the user to browse their system&rsquo;s file system and select a file to pull bounding box data from. The selected file&rsquo;s system path is stored in box_path and the file name is displayed to the ui. </span></p><h2 class="c15" id="h.ccp809xxhcur"><span class="c9">labelarea.h/labelarea.cpp</span></h2><h3 class="c2 c7" id="h.vf0kaqlwjjcd"><span class="c6">QGraphicsScene* setupScene();</span></h3><p class="c0"><span class="c3">Used for setting a QGraphicScene&rsquo;s initial settings. Sets default size to 600x800 and adds the class&rsquo;s eventfilter. Finally a cross patterned black grid is added to the back of the scene.</span></p><h3 class="c2 c7" id="h.r5mhcrgv58u9"><span>void </span><span>displayImg</span><span class="c6">(const QImage &amp;image, QGraphicsScene* _scene);</span></h3><p class="c0"><span class="c3">Takes in QImage and scene. Creates a QGraphicsPixmapItem from the QImage and adds it to the scene. The scene is then scaled to the image&rsquo;s size and its view is centered on the image.</span></p><h3 class="c2 c7" id="h.en9udutu5ysr"><span class="c6">bool eventFilter(QObject *watched, QEvent *event);</span></h3><p class="c0"><span>Used for tracking mouse events. Starts by setting the flags of all ResizableRectItems to false if in draw mode or true if not. This prevents selecting a box while in draw mode. Then checks if the mouse is pressed, and if so, stores the point where clicked relative to the scene position. Next it checks for a mouse release event, and if so draws a box. This is done by first checking if it is in draw mode, and If not, emits a boxMoved() signal. Next it calculates the bounding rect of the drawn rectangle using the point stored on mouse click and the point on mouse release. Finally the ResizableRectItemSettings and passed in to a new </span><span>ResizeableRectItem</span><span class="c3">&nbsp;along with the drawn rectangle coordinates and is added to the current scene along with a boxMade(item) signal.</span></p><h3 class="c2 c7" id="h.x06z04wf24x"><span class="c6">QGraphicsScene* getScene();</span></h3><p class="c0"><span class="c3">Returns widget&rsquo;s scene</span></p><h3 class="c2 c7" id="h.oqskvyayy4i9"><span class="c6">void setColor(QColor _color);</span></h3><p class="c0"><span class="c3">Changes color to _color</span></p><h3 class="c2 c7" id="h.8835ltja2bfc"><span class="c6">QColor getColor();</span></h3><p class="c0"><span class="c3">Returns color</span></p><h3 class="c2 c7" id="h.dcv03al8ww64"><span class="c6">void unselectAll();</span></h3><p class="c0"><span class="c3">Clears the scene&rsquo;s selection</span></p><h3 class="c2 c7" id="h.fsxranycmke1"><span class="c6">void setCurrentClass(QString _class);</span></h3><p class="c0"><span class="c3">Changes currentClass to _class</span></p><h3 class="c2 c7" id="h.fleuxd4twzyc"><span class="c6">void wheelEvent(QWheelEvent *event);</span></h3><p class="c0"><span class="c3">Adds scroll functionality. When the user scrolls using the mouse&rsquo;s scroll wheel, the scene is scaled relative to the scroll event.</span></p><h3 class="c2 c7" id="h.fdxasbaesgpw"><span class="c6">void boxMade(QGraphicsItem* band);</span></h3><p class="c0"><span class="c3">BoxMade(QGraphicsItem* band) signal</span></p><h3 class="c2" id="h.ll0vj3kkwkn4"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Void boxMoved()</span></h3><p class="c10"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boxMoved() signal</span></p><h2 class="c15" id="h.anxwwqnhbclg"><span class="c9">mainwindow.h/mainwindow.cpp</span></h2><h3 class="c2 c7" id="h.g7iaxiedjb3f"><span class="c6">void on_actionImport_triggered();</span></h3><p class="c0"><span class="c3">Calls import dialog gui, it&rsquo;s getters to obtain file path and parameters</span></p><p class="c0"><span class="c3">Calls extraction script to get .bag location and image destination</span></p><p class="c0"><span class="c3">Sets up annotation tree for inclusion of a formatted .txt file</span></p><p class="c0"><span class="c3">Draws images to the scenes in the frame viewer and timeline</span></p><p class="c0"><span class="c3">Readds bounding boxes specified in .txt file to the scenes</span></p><h3 class="c2 c7" id="h.fjrnxwjim47i"><span class="c6">void on_actionExport_triggered();</span></h3><p class="c0"><span class="c3">Calls export gui</span></p><p class="c0"><span class="c3">Creates a file at specified location that includes image number and the specifics for each of its boxes, including its class label, its position, and dimensions</span></p><p class="c0"><span class="c3">Changes to the export format can be done here</span></p><h3 class="c2 c7" id="h.44tz0a99snjh"><span class="c6">void on_newclassButton_clicked();</span></h3><p class="c0"><span class="c3">Creates and adds a new Annotation object and appends it to the class_list</span></p><p class="c0"><span class="c3">New Annotations have a &ldquo;New_&rdquo; name and are assigned a random color</span></p><p class="c0"><span class="c3">Class list is updated to show the new class under already created ones</span></p><p class="c0"><span class="c3">Current label is changed to the newly created class</span></p><h3 class="c2 c7" id="h.a86nldiugz2c"><span class="c6">void on_nextimgButton_clicked();</span></h3><p class="c0"><span class="c3">Find next timelineView and pass it to update_timeline()</span></p><h3 class="c2 c7" id="h.jw8otiw0f00x"><span class="c6">void on_previmgButton_clicked();</span></h3><p class="c0"><span class="c3">Find previous timelineView and pass it to update_timeline()</span></p><h3 class="c2 c7" id="h.clnaacvcs6l0"><span class="c6">void processExit(int , QProcess::ExitStatus);</span></h3><p class="c0"><span class="c3">No longer in use. </span></p><p class="c0"><span class="c3">Acts as a slot function that detects ExitStatus from a QProcess to allow for asynchronous script running.</span></p><h3 class="c2 c7" id="h.5j0320djszow"><span class="c6">void update_timeline(QWidget*);</span></h3><p class="c0"><span class="c3">Cast passed in Widget to timelineView</span></p><p class="c0"><span class="c3">Change stylesheet to highlight newly selected scene on the timeline</span></p><p class="c0"><span class="c3">Check if the newly selected scene is 1 after the previous scene, in which case copyBoxes() is called.</span></p><p class="c0"><span class="c3">See in the newly selected scene is after or before the previous scene</span></p><p class="c0"><span class="c3">Make sure newly selected scene is not one of the first 2 or last 3 scenes, then scale the scrollbar by 171 * newly selected scene&rsquo;s frame number-2</span></p><p class="c0"><span class="c3">(171 is used as it scales well with the size of the timeline)</span></p><h3 class="c2 c7" id="h.vjd0nq727dd"><span class="c6">void on_classTreeWidget_currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous);</span></h3><p class="c0"><span class="c3">Called when when another item other than the one currently selected on the class tree is selected</span></p><p class="c0"><span class="c3">If the item is a class then the current label is changed and drawing color is updated to reflect the current class</span></p><p class="c0"><span class="c3">If the item refers to a box, the QGraphicsItem is highlighted on the current scene</span></p><p class="c0 c4"><span class="c3"></span></p><h3 class="c2 c7" id="h.4tr3pb4okkhi"><span class="c6">void on_classTreeWidget_itemChanged(QTreeWidgetItem *item, int column);</span></h3><p class="c0"><span class="c3">Called when the currently selected item is edited</span></p><p class="c0"><span class="c3">Updates the associated annotation class based on the changes made to the item</span></p><h3 class="c2 c7" id="h.ebg9kzyxwuk5"><span class="c6">void on_classTreeWidget_itemDoubleClicked(QTreeWidgetItem *item, int column);</span></h3><p class="c0"><span class="c3">Unused</span></p><p class="c0"><span class="c3">Console debug</span></p><h3 class="c2 c7" id="h.t3vw6ichr7uh"><span class="c6">void on_labelarea_boxMade(QGraphicsItem* band);</span></h3><p class="c0"><span class="c3">Called when a QGraphicsItem is added to the current scene</span></p><p class="c0"><span class="c3">Attaches the item to the current label by appending the item to the annotation list</span></p><p class="c0"><span class="c3">Class tree is updated to include the item underneath its associated label</span></p><p class="c0"><span class="c3">Creates a ResizableRectItem associated with the GraphicsItem and sets its parameters with the annotation&rsquo;s assigned color</span></p><h3 class="c2 c7" id="h.2p5i0vuscwwk"><span class="c6">void on_deleteclassButton_clicked();</span></h3><p class="c0"><span class="c3">Called when the delete button is pressed</span></p><p class="c0"><span class="c3">Checks that the current class tree item refers to a QGraphicsItem</span></p><p class="c0"><span class="c3">Deletes the item updates the class tree list</span></p><p class="c0"><span class="c3">Does nothing otherwise</span></p><h3 class="c2 c7" id="h.7mwqamear6vg"><span class="c6">void on_labelarea_selectionChanged();</span></h3><p class="c0"><span class="c3">Disconnected signal slot</span></p><p class="c0"><span class="c3">Could be called to update the current selected class tree item based on which QGraphicsItem is selected </span></p><h3 class="c2 c7" id="h.khazvojbzngb"><span class="c6">void on_drawToolButton_clicked();</span></h3><p class="c0"><span class="c3">Changes labelarea&rsquo;s DragMode to RubberBandDrag</span></p><p class="c0"><span class="c3">Sets stylesheet of buttons to highlight the draw button</span></p><h3 class="c2 c7" id="h.9oc4oqt7xel5"><span class="c6">void on_selectionToolButton_clicked();</span></h3><p class="c0"><span class="c3">Changes labelarea&rsquo;s DragMode to NoDrag</span></p><p class="c0"><span class="c3">Sets stylesheet of buttons to highlight the tool button</span></p><h3 class="c2 c7" id="h.gi0jyetp108i"><span class="c6">void on_moveToolButton_clicked();</span></h3><p class="c0"><span class="c3">Changes labelarea&rsquo;s DragMode to ScrollHandDrag</span></p><p class="c0"><span class="c3">Sets stylesheet of buttons to highlight the tool button</span></p><h3 class="c2 c7" id="h.jxgvrcki18eh"><span class="c6">void on_editclassButton_clicked();</span></h3><p class="c0"><span class="c3">Create and initiate settingsdialog instance</span></p><p class="c0"><span class="c3">Update all scene&rsquo;s boxes to the new color from the settingsdialog</span></p><p class="c0"><span class="c3">Update all timeline&rsquo;s scene&rsquo;s boxes to the new color from the settingsdialog</span></p><h3 class="c2 c7" id="h.j7who1rhtdcw"><span class="c6">void draw_picture(QString,int);</span></h3><p class="c0"><span class="c3">Sets the labelarea scene to selected scene</span></p><p class="c0"><span class="c3">Create connection between boxMade() and on_labelarea_boxMade()</span></p><p class="c0"><span class="c3">Create connection between boxMoved() and on_labelarea_boxMoved()</span></p><p class="c0"><span class="c3">Call updateTreeList() to update the tree list to the new scene</span></p><h3 class="c2 c7" id="h.ko4wfz39njqz"><span class="c6">void timeline(QString directory);</span></h3><p class="c0"><span class="c3">Get number of images in directory</span></p><p class="c0"><span class="c3">Setup all of the QGraphicScenes</span></p><p class="c0"><span class="c3">Initialize QSignalMapper to create connection between slot() and update_timeline()</span></p><p class="c0"><span class="c3">For each img:</span></p><p class="c0"><span class="c3">Initialize new timelineView</span></p><p class="c0"><span class="c3">Get next image in directory and scale in to 165x165</span></p><p class="c0"><span class="c3">Initialize new QGraphicsScene</span></p><p class="c0"><span class="c3">Create QGraphicsPixmapItem, add it to scene, and scale the view to the image</span></p><p class="c0"><span class="c3">Create connection between clicked() signal and QSignalMapper</span></p><p class="c0"><span class="c3">Set view&rsquo;s frame_number and image_path</span></p><p class="c0"><span class="c3">Add view to QHBoxLayout</span></p><p class="c10"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Once all views are added, add QHBoxLayout to scrollArea on the ui</span></p><h3 class="c2 c7" id="h.19lca5oby5w0"><span class="c6">void get_num_images(QString directory);</span></h3><p class="c0"><span class="c3">Return number of images located in given directory</span></p><h3 class="c2 c7" id="h.f5kbvwnqd7rq"><span class="c6">Annotation* getAnnotationFromCurrentClass();</span></h3><p class="c0"><span class="c3">Return Annotation of currently selected class</span></p><h3 class="c2 c7" id="h.nlhmyzb2dad2"><span class="c6">Annotation* getAnnotationFromClass(QString className);</span></h3><p class="c0"><span class="c3">Return Annotation with the same name as className</span></p><h3 class="c2 c7" id="h.girdytlgk8d5"><span>QTreeWidgetItem* </span><span>findItemInList</span><span class="c6">(QGraphicsItem* item);</span></h3><p class="c0"><span>Searches the class list and the annotation lists for </span><span class="c18">item </span><span class="c3">and returns the associated class tree item</span></p><h3 class="c2 c7" id="h.9ldwlr8f8g7u"><span class="c6">void readClassList();</span></h3><p class="c0"><span class="c3">Puts to console the current name of all the labels</span></p><h3 class="c2 c7" id="h.xqaaervpuveo"><span class="c6">void keyPressEvent(QKeyEvent *e);</span></h3><p class="c0"><span class="c3">If S clicked -&gt; set labelarea DrawMode to ScrollHandDrag and forward to slot &nbsp;</span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function</span></p><p class="c0"><span>If A clicked -&gt; set </span><span>labelarea</span><span class="c3">&nbsp;DrawMode to NoDrag and forward to slot function</span></p><p class="c0"><span>If D clicked -&gt; set </span><span>labelarea</span><span class="c3">&nbsp;DrawMode to RubberBandDrag and forward to slot</span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function</span></p><h3 class="c2 c7" id="h.pj5zrckbcy0q"><span class="c6">void setupGraphicScenes();</span></h3><p class="c0"><span>Create scenes using </span><span>labelarea&rsquo;s</span><span class="c3">&nbsp;setupScene()</span></p><h2 class="c15" id="h.wf5m75t3brjd"><span class="c9">resizablerectitem.h/resizablerectitem.cpp</span></h2><h3 class="c2 c7" id="h.j83nxz64geyf"><span class="c6">void changeColor(QColor _color);</span></h3><p class="c0"><span class="c3">Change color to _color</span></p><h3 class="c2 c7" id="h.74vfqqi5gb1w"><span class="c6">void setClass(QString _class_name);</span></h3><p class="c0"><span class="c3">Change class_name to _class_name</span></p><h3 class="c2 c7" id="h.98wc2cw0le8c"><span class="c6">QString getClass();</span></h3><p class="c0"><span class="c3">Returns class_name</span></p><h3 class="c2 c7" id="h.hb3c5b64wfku"><span class="c6">void mousePressEvent(QGraphicsSceneMouseEvent *event);</span></h3><p class="c0"><span class="c3">Get the resize-directions. Then, if not a resize event, pass it to base class so the move event can be implemented. ELse, resizeRect()</span></p><p class="c0 c4"><span class="c3"></span></p><h3 class="c2 c7" id="h.759s3o6ysifc"><span class="c6">void mouseMoveEvent(QGraphicsSceneMouseEvent *event);</span></h3><p class="c0"><span class="c3">If not a resize event, pass it to the base class so the move event can be implemented. Else, resizeRect()</span></p><h3 class="c2 c7" id="h.a8cpf3x7n4l9"><span class="c6">void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);</span></h3><p class="c0"><span class="c3">If not a resize event, pass it to the base class so the move event can be implemented. Else, resizeRect()</span></p><h3 class="c2 c7" id="h.cvkbvhqw9us5"><span class="c6">void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);</span></h3><p class="c0"><span class="c3">Paint override to allow the inner-rect to be drawn before the outer-rect</span></p><h3 class="c2 c7" id="h.njd13ncmgrpz"><span class="c6">QRectF getInnerRect() const;</span></h3><p class="c0"><span class="c3">Returns rect() adjusted to settings resizableBorderSize</span></p><h3 class="c2 c7" id="h.qb58kp39obdg"><span class="c6">void resizeRect(QGraphicsSceneMouseEvent *event);</span></h3><p class="c0"><span class="c3">Resize based on QGraphicsSceneMouseEvent</span></p><h2 class="c15" id="h.d2p2m99yh3x5"><span class="c9">resizablerectitemsettings.h/resizablerectitemsettings.cpp</span></h2><h3 class="c2 c7" id="h.wmbnclh73yxl"><span class="c6">void validateRect(QRectF *r, const ResizeDirections &amp;resizeDirections) const;</span></h3><p class="c0"><span class="c3">Enforcement of the minimum and maximum sizes</span></p><h2 class="c15" id="h.ccfbmu8ifrub"><span class="c9">resizedirections.h</span></h2><h3 class="c2 c7" id="h.5mfen02e602p"><span class="c6">bool any();</span></h3><p class="c0"><span class="c3">Return either horizontal or vertical enum</span></p><h2 class="c15" id="h.5ssm0cqdh0f4"><span class="c9">settingsdialog.h/settingsdialog.cpp</span></h2><h3 class="c2 c7" id="h.d2z49bon4kb6"><span class="c6">void on_pushButton_color_clicked();</span></h3><p class="c0"><span class="c3">When pushButton_color is clicked, prompt a QColorDialog that lets the user select a color. This color is then set to the current select class along with the current set alpha. Finally, the color code is displayed to the ui.</span></p><h3 class="c2 c7" id="h.mb4q7dxdfwnv"><span class="c6">void on_comboBox_class_currentIndexChanged(int index);</span></h3><p class="c0"><span class="c3">Display newly selected class&rsquo;s color and alpha to the ui.</span></p><h3 class="c2 c7" id="h.b4irjaar3l7c"><span class="c6">void on_buttonBox_accepted();</span></h3><p class="c0"><span class="c3">If accepted, update the selected class with the currently selected alpha value then close the ui.</span></p><h3 class="c2" id="h.rt12v39ftrn0"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bool get_checked();</span></h3><p class="c10"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the checkstate of the checkBox</span></p><h2 class="c15" id="h.jt5b0efum4tm"><span class="c9">timelineview.h/timelineview.cpp</span></h2><h3 class="c2 c7" id="h.h97k1cb5t5xx"><span class="c6">void resizeEvent(QResizeEvent *event);</span></h3><p class="c0"><span class="c3">Override of the QGraphicsView resizeEvent to fit the view to its QGraphicPixmapItem.</span></p><h3 class="c2 c7" id="h.mk3dd4rq9i19"><span class="c6">void setFrameNum(int _frame_num);</span></h3><p class="c0"><span class="c3">Change frame_num to _frame_num</span></p><h3 class="c2 c7" id="h.yn1shmpabcxs"><span class="c6">int getFrameNum();</span></h3><p class="c0"><span class="c3">Returns frame_num.</span></p><h3 class="c2 c7" id="h.9sjilryfusan"><span class="c6">void setImagePath(QString _image_path);</span></h3><p class="c0"><span class="c3">Change image_path to _image_path.</span></p><h3 class="c2 c7" id="h.tvxua7kvkmq5"><span class="c6">QString getImagePath();</span></h3><p class="c0"><span class="c3">Returns image_path.</span></p><h3 class="c2 c7" id="h.d1cjcqosabbi"><span class="c6">void clicked();</span></h3><p class="c0"><span class="c3">clicked() signal</span></p><h3 class="c2 c7" id="h.1a2hogj3mfsy"><span class="c6">void mousePressEvent(QMouseEvent* event);</span></h3><p class="c0"><span class="c3">Emit clicked() signal on mousePressEvent</span></p></body></html>